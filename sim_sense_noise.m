%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   sim_sense_noise.m - Sense Channel Noise Model
%
%   Comprehensive noise model for the sense channel of an open-loop
%   capacitive MEMS gyroscope. Includes three independent axes (C, S, Z)
%   with the following noise sources:
%     - Reference voltage noise (Bandgap, IDAC, CM)
%     - MEMS noise (series resistors, Brownian motion)
%     - Sense C/V converter (OTA, parallel resistor)
%     - Rate integrator (signal resistors, OTA, finite gain)
%     - Common-mode voltage coupling (4 distinct paths)
%     - Drive noise coupling (quadrature compensation)
%     - Sigma-Delta modulation effects
%
%   References: noise_model.md Sections 3-6 (Sense Channel, CM Coupling,
%               Sigma-Delta, Pseudo-Sinusoidal Demodulation)
%
%   Usage: [sns_noise, C_sense, S_sense, Z_sense,
%            spectrum_C_cv, spectrum_S_cv, spectrum_Z_cv] = obj.sim_sense_noise()
%
%   Output Structures:
%     sns_noise       - Internal noise component breakdown
%     C/S/Z_sense     - Complete noise vectors for each axis
%     spectrum_*_cv   - Spectral analysis results
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [sns_noise, ...
    C_sense, S_sense, Z_sense, ...
    spectrum_C_cv, spectrum_S_cv, spectrum_Z_cv] = sim_sense_noise(obj)

    % ======================================================================
    % SECTION 0: CONFIGURATION AND PARAMETER INITIALIZATION
    % ======================================================================

    % Get configuration structures
    qc    = obj.imu.as.gyr.config.inf.qc;
    sense = obj.imu.as.gyr.config.inf.sense;
    ref   = obj.imu.as.gyr.config.inf.ref;
    drive = obj.info.drive;

    % Import physics constants
    import phys_pkg.*;

    % Initialize output structures
    sns_noise = struct();
    C_sense = struct();
    S_sense = struct();
    Z_sense = struct();
    spectrum_C_cv = struct();
    spectrum_S_cv = struct();
    spectrum_Z_cv = struct();

    % ======================================================================
    % CAPACITANCE CALCULATIONS (All three axes)
    % ======================================================================
    % These represent different measurement points and capacitance paths

    % Gate-to-common-mode capacitances (CP/CN to substrate)
    CG1_CGM  = (obj.imu.gyro.gyro.par.CGP1_CGM + obj.imu.gyro.gyro.par.CGN1_CGM)/2.0;
    CG2_CGM  = (obj.imu.gyro.gyro.par.CGP2_CGM + obj.imu.gyro.gyro.par.CGN2_CGM)/2.0;
    CG3_CGM  = (obj.imu.gyro.gyro.par.CGP3_CGM + obj.imu.gyro.gyro.par.CGN3_CGM)/2.0;

    % Gate-to-substrate parasitics
    CG1_SUB  = (obj.imu.gyro.gyro.par.CGP1_SUB + obj.imu.gyro.gyro.par.CGN1_SUB)/2.0;
    CG2_SUB  = (obj.imu.gyro.gyro.par.CGP2_SUB + obj.imu.gyro.gyro.par.CGN2_SUB)/2.0;
    CG3_SUB  = (obj.imu.gyro.gyro.par.CGP3_SUB + obj.imu.gyro.gyro.par.CGN3_SUB)/2.0;

    % Differential capacitance mismatches (CP minus CN)
    dCG1_SUB = (obj.imu.gyro.gyro.par.CGP1_SUB - obj.imu.gyro.gyro.par.CGN1_SUB);
    dCG2_SUB = (obj.imu.gyro.gyro.par.CGP2_SUB - obj.imu.gyro.gyro.par.CGN2_SUB);
    dCG3_SUB = (obj.imu.gyro.gyro.par.CGP3_SUB - obj.imu.gyro.gyro.par.CGN3_SUB);

    % Total gate capacitances (all coupling paths)
    CG1_ALL  = (obj.imu.gyro.gyro.par.CGP1_ALL + obj.imu.gyro.gyro.par.CGN1_ALL)/2.0;
    CG2_ALL  = (obj.imu.gyro.gyro.par.CGP2_ALL + obj.imu.gyro.gyro.par.CGN2_ALL)/2.0;
    CG3_ALL  = (obj.imu.gyro.gyro.par.CGP3_ALL + obj.imu.gyro.gyro.par.CGN3_ALL)/2.0;

    % ======================================================================
    % SECTION 1: REFERENCE VOLTAGE NOISE SOURCES
    % ======================================================================
    % Section 3.2 in noise_model.md

    % -----------------------------------------------------------------------
    % 1.1 BANDGAP REFERENCE NOISE
    % -----------------------------------------------------------------------
    % The bandgap voltage reference provides the system reference voltage
    % Includes thermal and flicker noise components
    
    [~, ref.bg.noise.bg_noise] = colouredNoise( ...
        (obj.ctrl.N-1)*1/obj.imu.as.gyr.config.inf.fs, ...
        obj.imu.as.gyr.config.inf.fs, ...
        ref.bg.noise.freq, ...
        obj.ctrl.noise_sel('Vref') * ref.bg.noise.vnd, ...
        43526, 0, 0, 1, false);

    % -----------------------------------------------------------------------
    % 1.2 IDAC CURRENT SOURCE NOISE
    % -----------------------------------------------------------------------
    % IDAC generates the reference current for rate feedback DAC
    
    [~, ref.idac.noise.idac_noise] = colouredNoise( ...
        (obj.ctrl.N-1)*1/obj.imu.as.gyr.config.inf.fs, ...
        obj.imu.as.gyr.config.inf.fs, ...
        ref.idac.noise.freq, ...
        obj.ctrl.noise_sel('IDAC') * ref.idac.noise.ind, ...
        64345, 0, 0, 1, false);

    % Combined IDAC and bandgap noise [A]
    idac_bg_noise = ref.idac.noise.idac_noise;

    % -----------------------------------------------------------------------
    % 1.3 BANDGAP+IDAC NOISE AT RATE INTEGRATOR INPUT
    % -----------------------------------------------------------------------
    % Convert IDAC noise to equivalent noise at C/V output
    % Scaled by signal gain and applied rate
    
    C_sense.cvout_bg_noise = (obj.ctrl.noise_sel('Vref_SD') * ...
        idac_bg_noise * (sense.rate.coeff.Kref_noise / sense.rate.coeff.Kin_noise) * ...
        sense.rate.common.res_sig12) * ...
        obj.sys.rate_y.Value / obj.imu.as.gyr.config.inf.FSdps;

    S_sense.cvout_bg_noise = (obj.ctrl.noise_sel('Vref_SD') * ...
        idac_bg_noise * (sense.rate.coeff.Kref_noise / sense.rate.coeff.Kin_noise) * ...
        sense.rate.common.res_sig12) * ...
        obj.sys.rate_x.Value / obj.imu.as.gyr.config.inf.FSdps;

    Z_sense.cvout_bg_noise = (obj.ctrl.noise_sel('Vref_SD') * ...
        idac_bg_noise * (sense.rate.coeff.Kref_noise / sense.rate.coeff.Kin_noise) * ...
        sense.rate.common.res_sig12) * ...
        obj.sys.rate_z.Value / obj.imu.as.gyr.config.inf.FSdps;

    % -----------------------------------------------------------------------
    % 1.4 COMMON-MODE VOLTAGE NOISE
    % -----------------------------------------------------------------------
    % Section 4 in noise_model.md - CM noise propagation
    % Includes LDO noise, bandgap-correlated component, and thermal noise
    
    % LDO-generated colored noise
    [~, ref.cm.noise.ldo_noise] = colouredNoise( ...
        (obj.ctrl.N-1)*1/obj.imu.as.gyr.config.inf.fs, ...
        obj.imu.as.gyr.config.inf.fs, ...
        ref.cm.noise.freq, ...
        obj.ctrl.noise_sel('VCM') * ref.cm.noise.vnd, ...
        87646, 0, 0, 1, false);

    % Bandgap-correlated CM noise [V]
    ref.cm.noise.vref_noise = obj.ctrl.noise_sel('Vref_CM') * ...
        (ref.cm.vout/ref.bg.vout) * ref.bg.noise.bg_noise;

    % Total CM voltage noise: filtered LDO + unfiltered thermal [V]
    [ref.cm.filt.b, ref.cm.filt.a] = sos2tf(ref.cm.filt.SOS, ref.cm.filt.G);
    ref.cm.noise.cm_noise = filtfilt(ref.cm.filt.b, ref.cm.filt.a, ...
        ref.cm.noise.ldo_noise + ref.cm.noise.vref_noise) + ...
        (ref.cm.noise.thermal_vnd25k * sqrt(obj.imu.as.gyr.config.inf.fs/2) * ...
        randn(1, obj.ctrl.N));

    % CM noise without bandgap correlation (for multi-path analysis)
    % Used to avoid double-counting bandgap component through multiple paths
    C_sense.cvout_cm_noise_uncorrelated = ref.cm.noise.cm_noise - ref.cm.noise.vref_noise;
    S_sense.cvout_cm_noise_uncorrelated = ref.cm.noise.cm_noise - ref.cm.noise.vref_noise;
    Z_sense.cvout_cm_noise_uncorrelated = ref.cm.noise.cm_noise - ref.cm.noise.vref_noise;

    % ======================================================================
    % SECTION 2: MEMS NOISE SOURCES
    % ======================================================================
    % Section 3.3 in noise_model.md

    % -----------------------------------------------------------------------
    % 2.1 MEMS SERIES RESISTOR NOISE (Sense electrodes)
    % -----------------------------------------------------------------------
    % Thermal noise from interconnect traces between MEMS and ASIC
    
    % Thermal noise density [V/√Hz] for each axis
    sns_noise.cv.noise.C.vn_rs = obj.ctrl.noise_sel('R_MEMS_C') * ...
        sqrt(4*phys.kT*(obj.imu.gyro.gyro.par.Rs_GP1 + obj.imu.gyro.gyro.par.Rs_GN1));
    
    sns_noise.cv.noise.S.vn_rs = obj.ctrl.noise_sel('R_MEMS_C') * ...
        sqrt(4*phys.kT*(obj.imu.gyro.gyro.par.Rs_GP2 + obj.imu.gyro.gyro.par.Rs_GN2));
    
    sns_noise.cv.noise.Z.vn_rs = obj.ctrl.noise_sel('R_MEMS_C') * ...
        sqrt(4*phys.kT*(obj.imu.gyro.gyro.par.Rs_GP3 + obj.imu.gyro.gyro.par.Rs_GN3));

    % Noise gain (distributed parasitic model)
    % Only capacitance before the series resistor counts
    sns_noise.cv.noise.C.rs_gain = ((CG1_CGM + CG1_SUB)/2.0) / sense.cv.C.gyr_cap_cv_s;
    sns_noise.cv.noise.S.rs_gain = ((CG2_CGM + CG2_SUB)/2.0) / sense.cv.S.gyr_cap_cv_s;
    sns_noise.cv.noise.Z.rs_gain = ((CG3_CGM + CG3_SUB)/2.0) / sense.cv.Z.gyr_cap_cv_s;

    % Total MEMS series resistor noise at C/V output [V/√Hz]
    C_sense.cvout_vn_rs = sns_noise.cv.noise.C.rs_gain * sns_noise.cv.noise.C.vn_rs;
    S_sense.cvout_vn_rs = sns_noise.cv.noise.S.rs_gain * sns_noise.cv.noise.S.vn_rs;
    Z_sense.cvout_vn_rs = sns_noise.cv.noise.Z.rs_gain * sns_noise.cv.noise.Z.vn_rs;

    % Generate time-domain noise vectors [V]
    C_sense.cvout_r_cpcn = C_sense.cvout_vn_rs * sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    S_sense.cvout_r_cpcn = S_sense.cvout_vn_rs * sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    Z_sense.cvout_r_cpcn = Z_sense.cvout_vn_rs * sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    % -----------------------------------------------------------------------
    % 2.2 MEMS BROWNIAN MECHANICAL NOISE
    % -----------------------------------------------------------------------
    % Fundamental thermodynamic limit from Brownian motion of sense mass
    % Expressed as equivalent angular rate noise [dps]
    
    C_sense.brw_noise_dps = obj.ctrl.noise_sel('MEMS_Brw') * ...
        obj.imu.gyro.gyro.fp.misc.brownian_noise.C * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    
    S_sense.brw_noise_dps = obj.ctrl.noise_sel('MEMS_Brw') * ...
        obj.imu.gyro.gyro.fp.misc.brownian_noise.S * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    
    Z_sense.brw_noise_dps = obj.ctrl.noise_sel('MEMS_Brw') * ...
        obj.imu.gyro.gyro.fp.misc.brownian_noise.Z * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    % ======================================================================
    % SECTION 3: SENSE C/V CONVERTER NOISE
    % ======================================================================
    % Section 3.4 in noise_model.md

    % -----------------------------------------------------------------------
    % 3.1 SENSE C/V NOISE GAIN CALCULATION
    % -----------------------------------------------------------------------
    % Accounts for all capacitances in the signal path
    % Formula: G_n = (C_gate,all + C_par,ASIC + C_in,pair + C_QC + C_CVS) / C_CVS
    
    sns_noise.cv.noise.C.cvs_gain = (CG1_ALL + obj.imu.as.gyr.par.Cpar_C + ...
        sense.cv.C.cin_pair + qc.C.gyr_cap_qc + sense.cv.C.gyr_cap_cv_s) / ...
        sense.cv.C.gyr_cap_cv_s;

    sns_noise.cv.noise.S.cvs_gain = (CG2_ALL + obj.imu.as.gyr.par.Cpar_C + ...
        sense.cv.S.cin_pair + qc.S.gyr_cap_qc + sense.cv.S.gyr_cap_cv_s) / ...
        sense.cv.S.gyr_cap_cv_s;

    sns_noise.cv.noise.Z.cvs_gain = (CG3_ALL + obj.imu.as.gyr.par.Cpar_C + ...
        sense.cv.Z.cin_pair + qc.Z.gyr_cap_qc + sense.cv.Z.gyr_cap_cv_s) / ...
        sense.cv.Z.gyr_cap_cv_s;

    % Effective capacitive "seen" for current->voltage conversion (consistent with cvs_gain numerator)
    sns_noise.cv.noise.C.Ctot = (CG1_ALL + obj.imu.as.gyr.par.Cpar_C + ...
        sense.cv.C.cin_pair + qc.C.gyr_cap_qc + sense.cv.C.gyr_cap_cv_s);

    sns_noise.cv.noise.S.Ctot = (CG2_ALL + obj.imu.as.gyr.par.Cpar_C + ...
        sense.cv.S.cin_pair + qc.S.gyr_cap_qc + sense.cv.S.gyr_cap_cv_s);

    sns_noise.cv.noise.Z.Ctot = (CG3_ALL + obj.imu.as.gyr.par.Cpar_C + ...
        sense.cv.Z.cin_pair + qc.Z.gyr_cap_qc + sense.cv.Z.gyr_cap_cv_s);

    % -----------------------------------------------------------------------
    % 3.2 SENSE C/V OTA NOISE (Colored)
    %     Flicker parameter is input-referred CURRENT noise @1Hz [A/sqrt(Hz)]
    %     Thermal parameter is input-referred VOLTAGE noise floor [V/sqrt(Hz)]
    % -----------------------------------------------------------------------
    f = sense.cv.noise.freq(:).';   % Hz (row)
    fmin_1f = 1;                    % avoid singularity at DC; tune if needed
    fe = max(f, fmin_1f);

    % i_1Hz [A/sqrt(Hz)] : prefer mc.i_1Hz, else legacy mc.K_f (mapped in init_gyr_stat)
    if isfield(obj.imu.as.gyr.stat.mc, 'i_1Hz')
        i1Hz = obj.imu.as.gyr.stat.mc.i_1Hz;
    else
        i1Hz = obj.imu.as.gyr.stat.mc.K_f;
    end

    % v_th [V/sqrt(Hz)]
    vth = obj.imu.as.gyr.stat.mc.v_th;

    % 1/f current ASD: i(f) = i1Hz * sqrt(1/f)
    i_f = i1Hz .* sqrt(1 ./ fe);  % [A/sqrt(Hz)]

    % Convert to equivalent input-referred voltage ASD through capacitive impedance:
    % v_flicker(f) = i(f) / (2*pi*f*Ctot)
    v_flick_C = i_f ./ (2*pi .* fe .* sns_noise.cv.noise.C.Ctot);
    v_flick_S = i_f ./ (2*pi .* fe .* sns_noise.cv.noise.S.Ctot);
    v_flick_Z = i_f ./ (2*pi .* fe .* sns_noise.cv.noise.Z.Ctot);

    % Combine thermal + flicker in RMS (both are input-referred voltage ASD)
    vnd_C = sqrt( (vth.^2) + (v_flick_C.^2) );
    vnd_S = sqrt( (vth.^2) + (v_flick_S.^2) );
    vnd_Z = sqrt( (vth.^2) + (v_flick_Z.^2) );

    % Generate colored input-referred voltage noise vectors [V] per axis
    [~, sns_noise.cv.noise.cvs_noise_C] = colouredNoise( ...
        (obj.ctrl.N-1)*1/(obj.imu.as.gyr.config.inf.fs), ...
        obj.imu.as.gyr.config.inf.fs, ...
        f, ...
        obj.ctrl.noise_sel('CVS') * vnd_C, ...
        542353, 0, 0, 1, false);

    [~, sns_noise.cv.noise.cvs_noise_S] = colouredNoise( ...
        (obj.ctrl.N-1)*1/(obj.imu.as.gyr.config.inf.fs), ...
        obj.imu.as.gyr.config.inf.fs, ...
        f, ...
        obj.ctrl.noise_sel('CVS') * vnd_S, ...
        542354, 0, 0, 1, false);

    [~, sns_noise.cv.noise.cvs_noise_Z] = colouredNoise( ...
        (obj.ctrl.N-1)*1/(obj.imu.as.gyr.config.inf.fs), ...
        obj.imu.as.gyr.config.inf.fs, ...
        f, ...
        obj.ctrl.noise_sel('CVS') * vnd_Z, ...
        542355, 0, 0, 1, false);

    % Ensure row vectors
    sns_noise.cv.noise.cvs_noise_C = sns_noise.cv.noise.cvs_noise_C(:).';
    sns_noise.cv.noise.cvs_noise_S = sns_noise.cv.noise.cvs_noise_S(:).';
    sns_noise.cv.noise.cvs_noise_Z = sns_noise.cv.noise.cvs_noise_Z(:).';
    % -----------------------------------------------------------------------
    % 3.3 PSEUDO-SINUSOIDAL MODULATION OF C/V NOISE
    % -----------------------------------------------------------------------
    % Section 6 in noise_model.md
    % OTA noise is modulated by pseudo-sine demodulation waveform
    % This translates noise from baseband to drive frequency
    
    % Generate pseudo-sinusoidal signal (period = 192 samples)
    pseudo_sin_signal = obj.pseudo_sin(0:obj.ctrl.N-1, 192);

        % Apply pseudo-sin modulation to OTA noise for each axis
    C_sense.cvout_cvs_ota = (sns_noise.cv.noise.cvs_noise_C * sns_noise.cv.noise.C.cvs_gain) .* ...
        pseudo_sin_signal;

    S_sense.cvout_cvs_ota = (sns_noise.cv.noise.cvs_noise_S * sns_noise.cv.noise.S.cvs_gain) .* ...
        pseudo_sin_signal;

    Z_sense.cvout_cvs_ota = (sns_noise.cv.noise.cvs_noise_Z * sns_noise.cv.noise.Z.cvs_gain) .* ...
        pseudo_sin_signal;

    % ======================================================================
    % SECTION 4: RATE INTEGRATOR NOISE
    % ======================================================================
    % Section 3.5 in noise_model.md

    % -----------------------------------------------------------------------
    % 4.1 RATE INTEGRATOR SIGNAL RESISTOR NOISE
    % -----------------------------------------------------------------------
    % Pseudo-sinusoidal demodulation uses time-varying resistor network
    % Equivalent to switched capacitor circuits
    
    sns_noise.rate.noise.common.vn_rsig = ...
        obj.ctrl.noise_sel('Rint_Rsign') * ...
        sqrt((2*4*phys.kT*sense.rate.common.res_sig12*sense.rate.phi_hi/(sense.rate.phi_per/4)) + ...
        (2*4*phys.kT*sense.rate.common.res_sig1*sense.rate.phi_lo/(sense.rate.phi_per/4)));

    % -----------------------------------------------------------------------
    % 4.2 RATE INTEGRATOR OTA FINITE GAIN EFFECTS
    % -----------------------------------------------------------------------
    % Virtual ground error due to finite OTA open-loop gain
    % Creates signal-dependent noise contribution
    
    % Virtual ground error voltage [V]
    sns_noise.rate.noise.C.veps = qc.C.quad_res * ...
        (sense.cv.C.cv_out/obj.imu.as.gyr.config.inf.FSdps) / ...
        10^(sense.rate.common.gain_70kHz/20);
    
    sns_noise.rate.noise.S.veps = qc.S.quad_res * ...
        (sense.cv.S.cv_out/obj.imu.as.gyr.config.inf.FSdps) / ...
        10^(sense.rate.common.gain_70kHz/20);
    
    sns_noise.rate.noise.Z.veps = qc.Z.quad_res * ...
        (sense.cv.Z.cv_out/obj.imu.as.gyr.config.inf.FSdps) / ...
        10^(sense.rate.common.gain_70kHz/20);

    % Noise contribution from finite gain (disabled by factor of 0 in original)
    % Enable if OTA gain is marginal (< 80 dB)
    sns_noise.rate.noise.C.vint_ota_gain = 0 * obj.ctrl.noise_sel('Rint_opa_gain') * ...
        sns_noise.rate.noise.C.veps * sense.rate.C.FS * ...
        (2*sqrt((1-(2/pi))*2/obj.imu.as.gyr.config.inf.fs)) / (pi*obj.imu.as.gyr.cm.vref);
    
    sns_noise.rate.noise.S.vint_ota_gain = 0 * obj.ctrl.noise_sel('Rint_opa_gain') * ...
        sns_noise.rate.noise.S.veps * sense.rate.S.FS * ...
        (2*sqrt((1-(2/pi))*2/obj.imu.as.gyr.config.inf.fs)) / (pi*obj.imu.as.gyr.cm.vref);
    
    sns_noise.rate.noise.Z.vint_ota_gain = 0 * obj.ctrl.noise_sel('Rint_opa_gain') * ...
        sns_noise.rate.noise.Z.veps * sense.rate.Z.FS * ...
        (2*sqrt((1-(2/pi))*2/obj.imu.as.gyr.config.inf.fs)) / (pi*obj.imu.as.gyr.cm.vref);

    % -----------------------------------------------------------------------
    % 4.3 RATE INTEGRATOR OTA THERMAL NOISE
    % -----------------------------------------------------------------------
    % OTA input-referred noise scaled by signal gain coefficient
    
    C_sense.cvout_rsig = sns_noise.rate.noise.common.vn_rsig * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    
    S_sense.cvout_rsig = sns_noise.rate.noise.common.vn_rsig * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    
    Z_sense.cvout_rsig = sns_noise.rate.noise.common.vn_rsig * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    % Rate integrator OTA noise [V]
    C_sense.cvout_rate_ota = ...
        (sqrt((obj.ctrl.noise_sel('Rint_opa')*sense.rate.noise.Vn_opa)^2 + ...
        sns_noise.rate.noise.C.vint_ota_gain^2) * ...
        sense.rate.coeff.Kin / sense.rate.coeff.Kin_noise) * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    S_sense.cvout_rate_ota = ...
        (sqrt((obj.ctrl.noise_sel('Rint_opa')*sense.rate.noise.Vn_opa)^2 + ...
        sns_noise.rate.noise.S.vint_ota_gain^2) * ...
        sense.rate.coeff.Kin / sense.rate.coeff.Kin_noise) * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    Z_sense.cvout_rate_ota = ...
        (sqrt((obj.ctrl.noise_sel('Rint_opa')*sense.rate.noise.Vn_opa)^2 + ...
        sns_noise.rate.noise.Z.vint_ota_gain^2) * ...
        sense.rate.coeff.Kin / sense.rate.coeff.Kin_noise) * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    % ======================================================================
    % SECTION 5: COMMON-MODE VOLTAGE NOISE COUPLING PATHS
    % ======================================================================
    % Section 4 in noise_model.md - 4 distinct CM coupling mechanisms

    % -----------------------------------------------------------------------
    % 5.1 CM NOISE OVER C0 CAPACITOR OFFSET (Path 1)
    % -----------------------------------------------------------------------
    % Capacitor mismatch converts CM voltage to differential signal
    % Modulated at drive frequency due to amplitude modulation of offset
    
    C_sense.cvout_cm_c0_noise = obj.ctrl.noise_sel('CM_C0') * ...
        (ref.cm.noise.cm_noise * ...
        (obj.imu.gyro.gyro.par.CGP1_CGN1 / sense.cv.C.gyr_cap_cv_s)) / sqrt(2) .* ...
        sin(2*pi*obj.imu.gyro.gyro.stat.mc.fd*obj.ctrl.t);

    S_sense.cvout_cm_c0_noise = obj.ctrl.noise_sel('CM_C0') * ...
        (ref.cm.noise.cm_noise * ...
        (obj.imu.gyro.gyro.par.CGP2_CGN2 / sense.cv.S.gyr_cap_cv_s)) / sqrt(2) .* ...
        sin(2*pi*obj.imu.gyro.gyro.stat.mc.fd*obj.ctrl.t);

    Z_sense.cvout_cm_c0_noise = obj.ctrl.noise_sel('CM_C0') * ...
        (ref.cm.noise.cm_noise * ...
        (obj.imu.gyro.gyro.par.CGP3_CGN3 / sense.cv.Z.gyr_cap_cv_s)) / sqrt(2) .* ...
        sin(2*pi*obj.imu.gyro.gyro.stat.mc.fd*obj.ctrl.t);

    % -----------------------------------------------------------------------
    % 5.2 CM NOISE THROUGH PARASITIC CAPACITANCE MISMATCH (Path 2)
    % -----------------------------------------------------------------------
    % Substrate parasitics differ between CP and CN paths
    % Creates alternate CM-to-differential conversion
    
    % CM coupling gain through parasitic mismatch
    sns_noise.cv.noise.C.cm_cpar_gain = CG1_CGM / ...
        (CG1_CGM + CG1_SUB + sense.cv.C.gyr_cap_cv_s + dCG1_SUB/2);
    
    sns_noise.cv.noise.S.cm_cpar_gain = CG2_CGM / ...
        (CG2_CGM + CG2_SUB + sense.cv.S.gyr_cap_cv_s + dCG2_SUB/2);
    
    sns_noise.cv.noise.Z.cm_cpar_gain = CG3_CGM / ...
        (CG3_CGM + CG3_SUB + sense.cv.Z.gyr_cap_cv_s + dCG3_SUB/2);

    % CM noise through parasitic mismatch [V]
    % Uses uncorrelated CM noise to avoid double-counting bandgap
    C_sense.cvout_cm_cpar_noise = obj.ctrl.noise_sel('CM_Par') * ...
        sns_noise.cv.noise.C.cm_cpar_gain * (dCG1_SUB) / sense.cv.C.gyr_cap_cv_s * ...
        C_sense.cvout_cm_noise_uncorrelated / sqrt(2) .* ...
        sin(2*pi*obj.imu.gyro.gyro.stat.mc.fd*obj.ctrl.t);

    S_sense.cvout_cm_cpar_noise = obj.ctrl.noise_sel('CM_Par') * ...
        sns_noise.cv.noise.S.cm_cpar_gain * (dCG2_SUB) / sense.cv.S.gyr_cap_cv_s * ...
        S_sense.cvout_cm_noise_uncorrelated / sqrt(2) .* ...
        sin(2*pi*obj.imu.gyro.gyro.stat.mc.fd*obj.ctrl.t);

    Z_sense.cvout_cm_cpar_noise = obj.ctrl.noise_sel('CM_Par') * ...
        sns_noise.cv.noise.Z.cm_cpar_gain * (dCG3_SUB) / sense.cv.Z.gyr_cap_cv_s * ...
        Z_sense.cvout_cm_noise_uncorrelated / sqrt(2) .* ...
        sin(2*pi*obj.imu.gyro.gyro.stat.mc.fd*obj.ctrl.t);

    % -----------------------------------------------------------------------
    % 5.3 CM NOISE THROUGH RATE SIGNAL MODULATION (Path 3)
    % -----------------------------------------------------------------------
    % Signal-dependent coupling: Coriolis-induced capacitance change
    % modulates the effect of CM voltage noise
    
    C_sense.cvout_cm_rate_noise = obj.ctrl.noise_sel('CM_rate') * ...
        (C_sense.cvout_cm_noise_uncorrelated * ...
        (obj.imu.gyro.gyro.stat.mc.Sdd_C_Fdps * obj.sys.rate_x.Value / ...
        sense.cv.C.gyr_cap_cv_s));

    S_sense.cvout_cm_rate_noise = obj.ctrl.noise_sel('CM_rate') * ...
        (S_sense.cvout_cm_noise_uncorrelated * ...
        (obj.imu.gyro.gyro.stat.mc.Sdd_S_Fdps * obj.sys.rate_y.Value / ...
        sense.cv.S.gyr_cap_cv_s));

    Z_sense.cvout_cm_rate_noise = obj.ctrl.noise_sel('CM_rate') * ...
        (Z_sense.cvout_cm_noise_uncorrelated * ...
        (obj.imu.gyro.gyro.stat.mc.Sdd_Z_Fdps * obj.sys.rate_z.Value / ...
        sense.cv.Z.gyr_cap_cv_s));

    % -----------------------------------------------------------------------
    % 5.4 CM NOISE DEMODULATED BY QUADRATURE MOTION (Path 4)
    % -----------------------------------------------------------------------
    % Residual quadrature (after compensation) acts as alternative carrier
    % Creates both rate and quadrature outputs
    
    % Rate component of CM noise demodulation [V]
    C_sense.cvout_cm_qdem_noise_r = obj.ctrl.noise_sel('CM_Qdem') * ...
        ((obj.imu.gyro.gyro.stat.mc.Sdd_C_Fdps * ...
        (obj.imu.gyro.gyro.stat.mc.quad_C + qc.C.quad_res)) / ...
        sense.cv.C.gyr_cap_cv_s) * ...
        sin(obj.imu.gyro.gyro.fp.detection.mechanical_phase.C/1000) * ...
        ref.cm.noise.cm_noise;

    S_sense.cvout_cm_qdem_noise_r = obj.ctrl.noise_sel('CM_Qdem') * ...
        ((obj.imu.gyro.gyro.stat.mc.Sdd_S_Fdps * ...
        (obj.imu.gyro.gyro.stat.mc.quad_S + qc.S.quad_res)) / ...
        sense.cv.S.gyr_cap_cv_s) * ...
        sin(obj.imu.gyro.gyro.fp.detection.mechanical_phase.S/1000) * ...
        ref.cm.noise.cm_noise;

    Z_sense.cvout_cm_qdem_noise_r = obj.ctrl.noise_sel('CM_Qdem') * ...
        ((obj.imu.gyro.gyro.stat.mc.Sdd_Z_Fdps * ...
        (obj.imu.gyro.gyro.stat.mc.quad_Z + qc.Z.quad_res)) / ...
        sense.cv.Z.gyr_cap_cv_s) * ...
        sin(obj.imu.gyro.gyro.fp.detection.mechanical_phase.Z/1000) * ...
        ref.cm.noise.cm_noise;

    % Quadrature component of CM noise demodulation [V]
    C_sense.cvout_cm_qdem_noise_q = obj.ctrl.noise_sel('CM_Qdem') * ...
        ((obj.imu.gyro.gyro.stat.mc.Sdd_C_Fdps * ...
        (obj.imu.gyro.gyro.stat.mc.quad_C + qc.C.quad_res)) / ...
        sense.cv.C.gyr_cap_cv_s) * ...
        cos(obj.imu.gyro.gyro.fp.detection.mechanical_phase.C/1000) * ...
        ref.cm.noise.cm_noise;

    S_sense.cvout_cm_qdem_noise_q = obj.ctrl.noise_sel('CM_Qdem') * ...
        ((obj.imu.gyro.gyro.stat.mc.Sdd_S_Fdps * ...
        (obj.imu.gyro.gyro.stat.mc.quad_S + qc.S.quad_res)) / ...
        sense.cv.S.gyr_cap_cv_s) * ...
        cos(obj.imu.gyro.gyro.fp.detection.mechanical_phase.S/1000) * ...
        ref.cm.noise.cm_noise;

    Z_sense.cvout_cm_qdem_noise_q = obj.ctrl.noise_sel('CM_Qdem') * ...
        ((obj.imu.gyro.gyro.stat.mc.Sdd_Z_Fdps * ...
        (obj.imu.gyro.gyro.stat.mc.quad_Z + qc.Z.quad_res)) / ...
        sense.cv.Z.gyr_cap_cv_s) * ...
        cos(obj.imu.gyro.gyro.fp.detection.mechanical_phase.Z/1000) * ...
        ref.cm.noise.cm_noise;

    % -----------------------------------------------------------------------
    % 5.5 ASIC PARALLEL INPUT RESISTOR NOISE
    % -----------------------------------------------------------------------
    % Large bias/ESD protection resistors contribute current noise
    
    sns_noise.cv.noise.C.vn_rp = obj.ctrl.noise_sel('Rpar_C') * ...
        sqrt(2*4*phys.kT/obj.imu.as.gyr.par.Rpar_in) * ...
        sense.cv.C.cv_gain_Iin_Vout;
    
    sns_noise.cv.noise.S.vn_rp = obj.ctrl.noise_sel('Rpar_C') * ...
        sqrt(2*4*phys.kT/obj.imu.as.gyr.par.Rpar_in) * ...
        sense.cv.S.cv_gain_Iin_Vout;
    
    sns_noise.cv.noise.Z.vn_rp = obj.ctrl.noise_sel('Rpar_C') * ...
        sqrt(2*4*phys.kT/obj.imu.as.gyr.par.Rpar_in) * ...
        sense.cv.Z.cv_gain_Iin_Vout;

    % Parallel resistor noise at C/V output [V]
    C_sense.cvout_rp = sns_noise.cv.noise.C.vn_rp * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    
    S_sense.cvout_rp = sns_noise.cv.noise.S.vn_rp * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);
    
    Z_sense.cvout_rp = sns_noise.cv.noise.Z.vn_rp * ...
        sqrt(obj.imu.as.gyr.config.inf.fs/2) * randn(1,obj.ctrl.N);

    % ======================================================================
    % SECTION 6: DRIVE NOISE COUPLING
    % ======================================================================
    % Quadrature compensation capacitor couples drive C/V noise to sense
    
    % Drive C/V noise through QC capacitor [V]
    C_sense.cvout_noise_qc = obj.ctrl.noise_sel('Quad_Comp') * ...
        drive.noise.cv.noise.vn_rand * qc.C.gyr_cap_qc / sense.cv.C.gyr_cap_cv_s;
    
    S_sense.cvout_noise_qc = obj.ctrl.noise_sel('Quad_Comp') * ...
        drive.noise.cv.noise.vn_rand * qc.S.gyr_cap_qc / sense.cv.S.gyr_cap_cv_s;
    
    Z_sense.cvout_noise_qc = obj.ctrl.noise_sel('Quad_Comp') * ...
        drive.noise.cv.noise.vn_rand * qc.Z.gyr_cap_qc / sense.cv.Z.gyr_cap_cv_s;

    % ======================================================================
    % SECTION 7: FINAL NOISE VECTOR ASSEMBLY AT C/V OUTPUT
    % ======================================================================
    % Combine all noise sources into complete rate and quadrature vectors
    
    % Total noise at C/V output for Rate calculations [V]
    C_sense.cvout_r = ...
        C_sense.cvout_bg_noise + ...
        C_sense.cvout_r_cpcn + ...
        C_sense.cvout_cvs_ota + ...
        C_sense.cvout_rsig + ...
        C_sense.cvout_rate_ota + ...
        C_sense.cvout_cm_c0_noise + ...
        C_sense.cvout_rp + ...
        C_sense.cvout_cm_qdem_noise_r + ...
        C_sense.cvout_cm_cpar_noise + ...
        C_sense.cvout_cm_rate_noise + ...
        C_sense.cvout_noise_qc;

    S_sense.cvout_r = ...
        S_sense.cvout_bg_noise + ...
        S_sense.cvout_r_cpcn + ...
        S_sense.cvout_cvs_ota + ...
        S_sense.cvout_rsig + ...
        S_sense.cvout_rate_ota + ...
        S_sense.cvout_cm_c0_noise + ...
        S_sense.cvout_rp + ...
        S_sense.cvout_cm_qdem_noise_r + ...
        S_sense.cvout_cm_cpar_noise + ...
        S_sense.cvout_cm_rate_noise + ...
        S_sense.cvout_noise_qc;

    Z_sense.cvout_r = ...
        Z_sense.cvout_bg_noise + ...
        Z_sense.cvout_r_cpcn + ...
        Z_sense.cvout_cvs_ota + ...
        Z_sense.cvout_rsig + ...
        Z_sense.cvout_rate_ota + ...
        Z_sense.cvout_cm_c0_noise + ...
        Z_sense.cvout_rp + ...
        Z_sense.cvout_cm_qdem_noise_r + ...
        Z_sense.cvout_cm_cpar_noise + ...
        Z_sense.cvout_cm_rate_noise + ...
        Z_sense.cvout_noise_qc;

    % ======================================================================
    % SECTION 8: QUADRATURE NOISE AND RATE INTEGRATOR INPUT
    % ======================================================================
    
    % -----------------------------------------------------------------------
    % 8.1 QUADRATURE NOISE DUE TO DRIVE PHASE NOISE
    % -----------------------------------------------------------------------
    % Residual quadrature modulates with drive phase noise
    
    C_sense.quad_noise_dps = qc.C.quad_res * drive.noise.pll.noise.phase_noise_drive;
    S_sense.quad_noise_dps = qc.S.quad_res * drive.noise.pll.noise.phase_noise_drive;
    Z_sense.quad_noise_dps = qc.Z.quad_res * drive.noise.pll.noise.phase_noise_drive;
    
    % -----------------------------------------------------------------------
    % 8.2 RATE INTEGRATOR INPUT NOISE
    % -----------------------------------------------------------------------
    % Account for demodulation coefficients and gain scaling

    C_sense.ratein_r = C_sense.cvout_r * sense.rate.coeff.Kin_noise / sense.rate.coeff.Kin;
    S_sense.ratein_r = S_sense.cvout_r * sense.rate.coeff.Kin_noise / sense.rate.coeff.Kin;
    Z_sense.ratein_r = Z_sense.cvout_r * sense.rate.coeff.Kin_noise / sense.rate.coeff.Kin;

    % Convert to angular rate units [dps] and add mechanical noise
    C_sense.ratein_r_dps = (C_sense.ratein_r / sense.cv.C.cv_gain) + ...
        C_sense.brw_noise_dps + C_sense.quad_noise_dps;
    
    S_sense.ratein_r_dps = (S_sense.ratein_r / sense.cv.S.cv_gain) + ...
        S_sense.brw_noise_dps + S_sense.quad_noise_dps;
    
    Z_sense.ratein_r_dps = (Z_sense.ratein_r / sense.cv.Z.cv_gain) + ...
        Z_sense.brw_noise_dps + Z_sense.quad_noise_dps;

    % ======================================================================
    % SECTION 9: SIGMA-DELTA MODULATION EFFECTS
    % ======================================================================
    % Section 5 in noise_model.md
    
    % -----------------------------------------------------------------------
    % 9.1 PHASE NOISE MODULATION OF SD FEEDBACK
    % -----------------------------------------------------------------------
    % SD feedback DAC switches at drive frequency
    % Drive phase noise modulates DAC current, creating multiplicative noise
    
    sns_noise.pll.sd_mod = ones(1,obj.ctrl.N) + ...
        (obj.ctrl.noise_sel('Qnoise_dem') * ...
        (2/sense.rate.common.sd1_nlev) * ...
        (drive.noise.pll.noise.phase_noise_drive + ...
        (sqrt(2)*idac_bg_noise/ref.idac.iout)));

    % ======================================================================
    % SECTION 10: SPECTRAL ANALYSIS AND VISUALIZATION
    % ======================================================================

    % Always compute spectral statistics (needed for results collection)
    % Only plot if plot_spectra_s is enabled
    if true  % Always compute, plotting controlled by plot_fft flags below
        % Plot Brownian noise for all axes
        spectrum_C_cv.brw_noise_dps = plotFunction(C_sense.brw_noise_dps, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('C MEMS Brownian Noise [dps]');
        end

        spectrum_S_cv.brw_noise_dps = plotFunction(S_sense.brw_noise_dps, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('S MEMS Brownian Noise [dps]');
        end

        spectrum_Z_cv.brw_noise_dps = plotFunction(Z_sense.brw_noise_dps, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('Z MEMS Brownian Noise [dps]');
        end

        % Plot total C/V output noise [V]
        spectrum_C_cv.cvout_r = plotFunction(C_sense.cvout_r, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'V', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('C Total Noise C/V Output [V]');
        end

        spectrum_S_cv.cvout_r = plotFunction(S_sense.cvout_r, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'V', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('S Total Noise C/V Output [V]');
        end

        spectrum_Z_cv.cvout_r = plotFunction(Z_sense.cvout_r, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'V', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('Z Total Noise C/V Output [V]');
        end

        % Plot C/V output noise in dps
        spectrum_C_cv.cvout_r_dps = plotFunction(C_sense.cvout_r / sense.cv.C.cv_gain, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('C Total Noise C/V Output [dps]');
        end

        spectrum_S_cv.cvout_r_dps = plotFunction(S_sense.cvout_r / sense.cv.S.cv_gain, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('S Total Noise C/V Output [dps]');
        end

        spectrum_Z_cv.cvout_r_dps = plotFunction(Z_sense.cvout_r / sense.cv.Z.cv_gain, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('Z Total Noise C/V Output [dps]');
        end

        % Plot rate integrator input noise [V]
        spectrum_C_cv.ratein_r = plotFunction(C_sense.ratein_r, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'V', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('C Total Noise SD Rate In [V]');
        end

        spectrum_S_cv.ratein_r = plotFunction(S_sense.ratein_r, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'V', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('S Total Noise SD Rate In [V]');
        end

        spectrum_Z_cv.ratein_r = plotFunction(Z_sense.ratein_r, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'V', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('Z Total Noise SD Rate In [V]');
        end

        % Plot rate integrator input noise [dps]
        spectrum_C_cv.ratein_r_dps = plotFunction(C_sense.ratein_r_dps, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('C Total Noise SD Rate In [dps]');
        end

        spectrum_S_cv.ratein_r_dps = plotFunction(S_sense.ratein_r_dps, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('S Total Noise SD Rate In [dps]');
        end

        spectrum_Z_cv.ratein_r_dps = plotFunction(Z_sense.ratein_r_dps, ...
            'fs', obj.imu.as.gyr.config.inf.fs, 'fb', obj.ctrl.fb, ...
            'stats', true, 'unit', 'dps', 'plot_fft', false, ...
            'new_fig', false);
        if obj.ctrl.plot_fft
            set(gca,'xscale','linear');
            set(gca,'XLim', [0 obj.ctrl.fb]/1000);
            title('Z Total Noise SD Rate In [dps]');
        end
    end
    
end
